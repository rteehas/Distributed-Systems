import sys

def byzantine_faults(m, reformatted, command, p=False):
    '''
    
    :param m: integer, level of recursion
    :param lieut_comm: list of tuples with the commander and lieutenants
    :param command: string, command to send to lieutenants
    :param p: boolean, tells you whether or not to print the output
    :return: dictionary that maps the index of a lieutenant to A, R, -
    '''
    # get dictionaries to relate commands to letters
    opposite = {'A': 'R', 'R':'A'}
    # get dict to relate final strings to printout commands for the end
    output = {'A': 'ATTACK', 'R': 'RETREAT', '-': 'TIE'}
    commands = {}
    # only look at commands sent to lieutenants, not commander
    for lu in reformatted[1:]:
        if reformatted[0][1] == 'T':
            if lu[0] % 2 == 0:
                comm = opposite[command]
            else:
                comm = command
        else:
            comm = command

        commands[lu[0]] = comm

    # base case
    if m == 0:
        return commands

    else:
        # deal with the recursion
        recur = {}
        for i in range(len(reformatted[1:])):
            # create a new list of lietenants with a new commander
            # where the new commander is the first in the list
            lut2 = [reformatted[i+1]] + reformatted[1:i+1] + reformatted[i + 2:]
            comm2 = commands[reformatted[i+1][0]]
            sub_probs = byzantine_faults(m-1, lut2, comm2)
            # record the results of the sub problems generated by the recursion
            for prob in sub_probs:
                if prob not in recur:
                    recur[prob] = [sub_probs[prob]]
                else:
                    recur[prob].append(sub_probs[prob])
        print(recur, m, "votes")
        results = {}
        for key in recur:
            # combine the results with the original commands
            combined = recur[key]
            combined.append(commands[key])
            a_count = 0
            r_count = 0
            # only increment for A and R to get the plurality/majority vote
            for i in combined:
                if i == 'A':
                    a_count += 1
                elif i == 'R':
                    r_count += 1

            # get final decision from the vote
            if a_count > r_count:
                final = 'A'
            elif r_count > a_count:
                final = 'R'
            else:
                final = '-'
            results[key] = final
        print(results, m, "final")
        if p:
            lieut_len = len(reformatted) #number of lieutenants/generals
            for i in range(lieut_len- 1):
                lieut_id = reformatted[i+1][0] # number associated with each lieutenant
                lieut_loyalty = reformatted[i+1][1] # T or L
                s = commands[i+1][0] + " "
                for j in range(len(recur[lieut_id]) - 1):
                    if i==j:
                        # add a space for when the indices match
                        s += " "
                    # add the vote that the index pair gives to the final tally
                    s += recur[lieut_id][j]
                if i == lieut_len - 2:
                    # add a space at the end before you print out the final results
                    s += " "
                # convert from characters to commands for the final commands
                s += " " + output[results[i+1]]
                if lieut_loyalty == "T":
                    # add an asterisk for traitors
                    s += "*"
                print(s)

        return results




if __name__ == "__main__":
    # read the arguments in from stdin
    args = sys.stdin.readline().strip("\n").split(" ")
    m = int(args[0])
    comm_lieut = args[1]
    command = args[2]
    # convert from commands to characters
    if command == "ATTACK":
        command = 'A'
    else:
        command = "R"

    # convert the lieutenants and commander to (index, command) format to identify lieutenants
    reformatted = []
    for i, l in enumerate(comm_lieut):
        reformatted.append((i, l))


    byzantine_faults(m, reformatted, command, True)